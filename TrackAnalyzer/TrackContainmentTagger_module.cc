////////////////////////////////////////////////////////////////////////
// Class:       TrackContainmentTagger
// Module Type: producer
// File:        TrackContainmentTagger_module.cc
//
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include "art/Framework/Services/Optional/TFileService.h"

#include "TTree.h"

#include "TrackAnalysis/TrackAnalysis.hh"
#include "Geometry/Geometry.h"
#include "Utilities/AssociationUtil.h"

namespace trk {
  class TrackContainmentTagger;
}

class trk::TrackContainmentTagger : public art::EDProducer {
public:
  explicit TrackContainmentTagger(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  TrackContainmentTagger(TrackContainmentTagger const &) = delete;
  TrackContainmentTagger(TrackContainmentTagger &&) = delete;
  TrackContainmentTagger & operator = (TrackContainmentTagger const &) = delete;
  TrackContainmentTagger & operator = (TrackContainmentTagger &&) = delete;

  // Required functions.
  void produce(art::Event & e) override;

  // Selected optional functions.
  void reconfigure(fhicl::ParameterSet const & p) override;

private:

  // Declare member data here.
  trk::TrackAnalysis fAlg;

  std::vector<std::string> fTrackModuleLabels;
  std::vector<bool>        fApplyTags;
};


trk::TrackContainmentTagger::TrackContainmentTagger(fhicl::ParameterSet const & p)
//  :
{
  art::ServiceHandle<art::TFileService> tfs;
  fAlg.SetupOutputTree(tfs->make<TTree>("myanatree","MyAnalysis Tree"));
  this->reconfigure(p);

  produces< std::vector<anab::CosmicTag> >();
  produces< art::Assns<recob::Track, anab::CosmicTag> >();
}

void trk::TrackContainmentTagger::produce(art::Event & e)
{

  std::unique_ptr< std::vector< anab::CosmicTag > >              cosmicTagTrackVector( new std::vector<anab::CosmicTag> );
  std::unique_ptr< art::Assns<recob::Track, anab::CosmicTag > >  assnOutCosmicTagTrack( new art::Assns<recob::Track, anab::CosmicTag>);
  
  fAlg.SetRunEvent(e.run(),e.event());
  
  std::vector< std::vector<recob::Track> > trackVectors;
  std::vector< art::Handle< std::vector<recob::Track> > > trackHandles(fTrackModuleLabels.size());
  for(size_t i_l=0; i_l<fTrackModuleLabels.size(); ++i_l){
    e.getByLabel(fTrackModuleLabels[i_l],trackHandles[i_l]);
    trackVectors.push_back(*trackHandles[i_l]);
  }
  
  art::ServiceHandle<geo::Geometry> geoHandle;
  fAlg.ProcessTracks(trackVectors,*geoHandle);

  auto const& cosmicTags = fAlg.GetTrackCosmicTags();

  for(size_t i_tc=0; i_tc<cosmicTags.size(); ++i_tc){
    if(!fApplyTags[i_tc]) continue;
    for(size_t i_t=0; i_t<fAlg.GetTrackCosmicTags()[i_tc].size(); ++i_t){
      cosmicTagTrackVector->emplace_back(fAlg.GetTrackCosmicTags()[i_tc][i_t]);
      util::CreateAssn(*this, e, *cosmicTagTrackVector, art::Ptr<recob::Track>(trackHandles[i_tc],i_t), *assnOutCosmicTagTrack );
    }
  }

  e.put(std::move(cosmicTagTrackVector));
  e.put(std::move(assnOutCosmicTagTrack));
  
}

void trk::TrackContainmentTagger::reconfigure(fhicl::ParameterSet const & p)
{
  fAlg.Configure(p.get<fhicl::ParameterSet>("TrackAnalysisAlg"));
  fTrackModuleLabels = p.get< std::vector<std::string> >("TrackModuleLabels");
  fApplyTags = p.get< std::vector<bool> >("ApplyTags",std::vector<bool>(fTrackModuleLabels.size(),true));

  if(fApplyTags.size()!=fTrackModuleLabels.size())
    throw cet::exception("TrackContainmentTagger::reconfigure")
      << "ApplyTags not same size as TrackModuleLabels. ABORT!!!";

  fAlg.setMakeCosmicTags();
}

DEFINE_ART_MODULE(trk::TrackContainmentTagger)
